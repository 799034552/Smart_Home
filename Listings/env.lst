C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ENV
OBJECT MODULE PLACED IN .\Objects\env.obj
COMPILER INVOKED BY: E:\C\keil\C51\BIN\C51.EXE User\env.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\User) DEBUG PRINT(.\Lis
                    -tings\env.lst) TABS(2) OBJECT(.\Objects\env.obj)

line level    source

   1          #include "env.h"
   2          #include "uart.h"
   3          #include "math.h"
   4          #include <stdio.h>
   5          sbit wet = P2^2;
   6          #define light_address 0x46                //光照传感器
   7          #define BMP085_SlaveAddress   0xee        //气压传感器
   8          #define JUDGE  30                         //湿度传感器阈值
   9          #define uchar unsigned char
  10          #define uint unsigned int
  11          /*****
  12          光照传感器
  13          ******/
  14          float temp;
  15          /*****
  16          气压传感器
  17          ******/
  18          xdata short ac1,ac2,ac3,b1,b2,mb,mc,md;
  19          xdata unsigned short ac4,ac5,ac6;
  20          long  temperature,pressure;
  21          /*****
  22          湿度传感器
  23          ******/
  24          uchar wet_data = 0;
  25          xdata uchar   ge,shi,bai,qian,wan,shiwan;
  26          xdata uchar res[] = "111111\r\n"; //结果
  27          
  28          xdata char temp1[35] = {'\0'};
  29          
  30          //------延迟函数------------
  31          void delay(uint t)    //@11.0592MHz
  32          {
  33   1        uint i,j,k;
  34   1        for(k=0;k<t;k++)
  35   1        for( i=0; i<10; i++)
  36   1        for( j=0; j<95; j++);
  37   1      }
  38          /*********************
  39                转换函数
  40          **********************/
  41          void conversion(long temp_data)  
  42          {
  43   1          shiwan=temp_data/100000+0x30 ;
  44   1          temp_data=temp_data%100000;   //取余运算 
  45   1          wan=temp_data/10000+0x30 ;
  46   1          temp_data=temp_data%10000;   //取余运算
  47   1        qian=temp_data/1000+0x30 ;
  48   1          temp_data=temp_data%1000;    //取余运算
  49   1          bai=temp_data/100+0x30   ;
  50   1          temp_data=temp_data%100;     //取余运算
  51   1          shi=temp_data/10+0x30    ;
  52   1          temp_data=temp_data%10;      //取余运算
  53   1          ge=temp_data+0x30;  
  54   1      }
C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 2   

  55          void light_write(uchar regis)
  56          {
  57   1        start();
  58   1        write_byte(light_address);
  59   1        write_byte(regis);
  60   1        stop();
  61   1      }
  62          void light_start(void)
  63          {
  64   1        light_write(0x01);
  65   1        light_write(0x10);
  66   1        delay(200);
  67   1      }
  68          
  69          float light_read(void)
  70          {   
  71   1        uchar i;
  72   1        uchar BUF[8];
  73   1        int dis_data;
  74   1        start();                          //起始信号
  75   1        write_byte(light_address+1);         //发送设备地址+读信号
  76   1        for (i=0; i<3; i++)                      //连续读取2个地址数据，存储中BUF
  77   1        {
  78   2          BUF[i] = read_byte();          //BUF[0]存储0x32地址中的数据
  79   2          if (i == 3)
  80   2          {
  81   3             send_respons(1);                //最后一个数据需要回NOACK
  82   3          }
  83   2          else
  84   2          {   
  85   3            send_respons(0);                //回应ACK
  86   3         }
  87   2        }
  88   1        stop();                          //停止信号
  89   1        delay(5);
  90   1        dis_data=BUF[0];
  91   1        dis_data=(dis_data<<8)+BUF[1];//合成数据，即光照数据
  92   1        temp = (float)dis_data/1.2;
  93   1        return temp;
  94   1      }
  95          uchar* getLightStr(void)
  96          {
  97   1        conversion(temp);         //计算数据和显示
  98   1        res[5] = ge;
  99   1        res[4] = shi;
 100   1        res[3] = bai;
 101   1        res[2] = qian;
 102   1        res[1] = wan;
 103   1        res[0] = shiwan;
 104   1        return res;
 105   1      }
 106          /*****************
 107            气压传感器
 108          ******************/
 109          //*********************************************************
 110          //读出BMP085内部数据,连续两个
 111          //*********************************************************
 112          short press_Multiple_read(uchar ST_Address)
 113          {
 114   1        uchar msb, lsb;
 115   1        short _data;
 116   1        start();                          //起始信号
C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 3   

 117   1        write_byte(BMP085_SlaveAddress);    //发送设备地址+写信号
 118   1        write_byte(ST_Address);             //发送存储单元地址
 119   1        start();                          //起始信号
 120   1        write_byte(BMP085_SlaveAddress+1);         //发送设备地址+读信号
 121   1      
 122   1        msb = read_byte();                 //BUF[0]存储
 123   1        send_respons(0);                       //回应ACK
 124   1        lsb = read_byte();     
 125   1        send_respons(1);                       //最后一个数据需要回NOACK
 126   1      
 127   1        stop();                           //停止信号
 128   1        delay(5);
 129   1        _data = msb << 8;
 130   1        _data |= lsb; 
 131   1        return _data;
 132   1      }
 133          long bmp085ReadTemp(void)
 134          {
 135   1      
 136   1          start();                  //起始信号
 137   1          write_byte(BMP085_SlaveAddress);   //发送设备地址+写信号
 138   1          write_byte(0xF4);           // write register address
 139   1          write_byte(0x2E);         // write register data for temp
 140   1          stop();                   //发送停止信号
 141   1          delay(10);  // max time is 4.5ms
 142   1        return (long) press_Multiple_read(0xF6);
 143   1      }
 144          long bmp085ReadPressure(void)
 145          {
 146   1        long pressure = 0;
 147   1        start();                   //起始信号
 148   1        write_byte(BMP085_SlaveAddress);   //发送设备地址+写信号
 149   1        write_byte(0xF4);           // write register address
 150   1        write_byte(0x34);           // write register data for pressure
 151   1        stop();                    //发送停止信号
 152   1        delay(10);                        // max time is 4.5ms
 153   1        pressure = press_Multiple_read(0xF6);
 154   1        pressure &= 0x0000FFFF;
 155   1        return pressure;  
 156   1      }
 157          void press_init()
 158          {
 159   1        ac1 = press_Multiple_read(0xAA);
 160   1        ac2 = press_Multiple_read(0xAC);
 161   1        ac3 = press_Multiple_read(0xAE);
 162   1        ac4 = press_Multiple_read(0xB0);
 163   1        ac5 = press_Multiple_read(0xB2);
 164   1        ac6 = press_Multiple_read(0xB4);
 165   1        b1 =  press_Multiple_read(0xB6);
 166   1        b2 =  press_Multiple_read(0xB8);
 167   1        mb =  press_Multiple_read(0xBA);
 168   1        mc =  press_Multiple_read(0xBC);
 169   1        md =  press_Multiple_read(0xBE);
 170   1      }
 171          long get_temperature()
 172          {
 173   1        long ut;
 174   1        long x1, x2, b5;
 175   1        ut = bmp085ReadTemp();     // 读取温度
 176   1        x1 = ((long)ut - ac6) * ac5 >> 15;
 177   1        x2 = ((long) mc << 11) / (x1 + md);
 178   1        b5 = x1 + x2;
C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 4   

 179   1        temperature = (b5 + 8) >> 4;
 180   1        return temperature;
 181   1      }
 182          uchar* getTempStr(void)
 183          {
 184   1        conversion(temperature);        
 185   1        res[5] = ge;
 186   1        res[4] = shi;
 187   1        res[3] = bai;
 188   1        res[2] = qian;
 189   1        res[1] = wan;
 190   1        res[0] = shiwan;
 191   1        return res;
 192   1      }
 193          long get_pressure()
 194          {
 195   1        long up;
 196   1        long x1, x2, b5, b6, x3, b3, p;
 197   1        unsigned long b4, b7;
 198   1        up = bmp085ReadPressure();  // 读取压强
 199   1        b6 = b5 - 4000;
 200   1        x1 = (b2 * (b6 * b6 >> 12)) >> 11;
 201   1        x2 = ac2 * b6 >> 11;
 202   1        x3 = x1 + x2;
 203   1        b3 = (((long)ac1 * 4 + x3) + 2)/4;
 204   1        x1 = ac3 * b6 >> 13;
 205   1        x2 = (b1 * (b6 * b6 >> 12)) >> 16;
 206   1        x3 = ((x1 + x2) + 2) >> 2;
 207   1        b4 = (ac4 * (unsigned long) (x3 + 32768)) >> 15;
 208   1        b7 = ((unsigned long) up - b3) * (50000 >> 0);
 209   1        if( b7 < 0x80000000)
 210   1          p = (b7 * 2) / b4 ;
 211   1        else  
 212   1          p = (b7 / b4) * 2;
 213   1        x1 = (p >> 8) * (p >> 8);
 214   1        x1 = (x1 * 3038) >> 16;
 215   1        x2 = (-7357 * p) >> 16;
 216   1        pressure = p + ((x1 + x2 + 3791) >> 4);
 217   1        return pressure;
 218   1      }
 219          uchar* getPressureStr(void)
 220          {
 221   1        conversion(pressure);        
 222   1        res[5] = ge;
 223   1        res[4] = shi;
 224   1        res[3] = bai;
 225   1        res[2] = qian;
 226   1        res[1] = wan;
 227   1        res[0] = shiwan;
 228   1        return res;
 229   1      }
 230          /*****************
 231            湿度传感器
 232          ******************/
 233          void Delay30us()
 234          {
 235   1        unsigned char i;
 236   1      
 237   1        i = 80;
 238   1        while (--i);
 239   1      }
 240          void Delay20ms()
C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 5   

 241          {
 242   1        unsigned char i, j, k;
 243   1      
 244   1        i = 1;
 245   1        j = 216;
 246   1        k = 35;
 247   1        do
 248   1        {
 249   2          do
 250   2          {
 251   3            while (--k);
 252   3          } while (--j);
 253   2        } while (--i);
 254   1      }
 255          uchar GetData (void)
 256          {
 257   1        uchar i,j;                                //for循环变量
 258   1        uchar t;                                //超时判断
 259   1        uchar dat8=0;                        //一次读取的8位数据，需要读5次
 260   1        wet = 0;                                //主机发起始信号
 261   1        Delay20ms();                        //主机拉低总线至少18ms
 262   1        wet = 1;                                //主机拉高总线20~40us
 263   1        Delay30us();
 264   1        t = 80;                                        //设置超时等待时间
 265   1        while(wet && t--);                //等待DHT11拉低总线
 266   1        if(t == 0)                                //超时
 267   1        {
 268   2          wet = 1;
 269   2          return 0;                        //通信错误退出，返回错误信号：-1
 270   2        }
 271   1        //等80us响应信号
 272   1        t = 250;                                //设置超时等待时间
 273   1        while(!wet && t--);        //等待DHT11拉高总线
 274   1        if(t == 0)                                //超时
 275   1        {
 276   2          wet = 1;
 277   2          return 0;                        //通信错误退出，返回错误信号：-2
 278   2        }
 279   1        //等80us响应信号
 280   1        t = 250;                                //设置超时等待时间
 281   1        while(wet && t--);                //等待DHT11拉低总线
 282   1        if(t == 0)                                //超时
 283   1        {
 284   2          wet = 1;
 285   2          return 0;                        //通信错误退出，返回错误信号：-3
 286   2        }
 287   1      
 288   1        for(j=0; j<5; j++)                //5次读取
 289   1        {
 290   2          for(i=0; i<8; i++)                        //1次8个位
 291   2          {
 292   3            //等待50us开始时隙
 293   3            t = 150;                                //设置超时等待时间
 294   3            while(!wet && t--);        //等待DHT11拉高总线
 295   3            if(t == 0)                                //超时
 296   3            {
 297   4              wet = 1;
 298   4              return 0;                        //通信错误退出，返回错误信号：-4
 299   4            }
 300   3            t = 0;                                        //记录时间清零
 301   3            while(wet && ++t);                //等待并记录高电平持续时间
 302   3            dat8 <<= 1;
C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 6   

 303   3            if(t > JUDGE)                        //高电平持续时间较长(70us)
 304   3              dat8 += 1;                        //传输值为1
 305   3          }
 306   2          if(j == 0)
 307   2            wet_data = dat8;
 308   2        }
 309   1        Delay30us();                //等待DHT11拉低50us
 310   1        Delay30us();
 311   1        wet = 1;                        //结束，拉高总线
 312   1        return wet_data;                        //返回成功信号
 313   1      }
 314          uchar* getWetStr(void)
 315          {
 316   1        conversion(wet_data);        
 317   1        res[5] = ge;
 318   1        res[4] = shi;
 319   1        res[3] = bai;
 320   1        res[2] = qian;
 321   1        res[1] = wan;
 322   1        res[0] = shiwan;
 323   1        return res;
 324   1      }
 325          /*****************
 326            显示温度
 327          ******************/
 328          void showTemperature()
 329          {
 330   1        get_temperature();
 331   1        getTempStr();
 332   1        uart2Clear();
 333   1        uart2AddChar("SBC(1);DCV24(245,50,'");
 334   1        uart2AddCharLen(res+3,1);
 335   1        uart2AddCharLen(res+4,1);
 336   1        uart2AddChar(".");
 337   1        uart2AddCharLen(res+5,1);
 338   1        uart2AddChar("℃',16);");
 339   1        uart2SendEnd();
 340   1      }
 341          void showPress()
 342          {
 343   1        get_pressure();
 344   1        getPressureStr();
 345   1        uart2Clear();
 346   1        uart2AddChar("SBC(49);DCV16(170,164,'");
 347   1        res[4] = res[3];
 348   1        res[3] = '.';
 349   1        res[5] = '\0';
 350   1        uart2AddChar(res);
 351   1        uart2AddChar("KPa',16);");
 352   1        uart2SendEnd();
 353   1      }
 354          void showLight()
 355          {
 356   1        uchar i;
 357   1        light_start();
 358   1        light_read();
 359   1        getLightStr();
 360   1        uart2Clear();
 361   1        uart2AddChar("SBC(13);DCV16(103,200,'");
 362   1        while(res[i++] == '0');
 363   1        i--;
 364   1        res[6] = '\0';
C51 COMPILER V9.54   ENV                                                                   06/10/2021 15:58:45 PAGE 7   

 365   1        uart2AddChar(res+i);
 366   1        uart2AddChar("Lux ',16);");
 367   1        uart2SendEnd();
 368   1      }
 369          void showWet()
 370          {
 371   1          if(GetData())
 372   1          {
 373   2            getWetStr();
 374   2            uart2Clear();
 375   2            uart2AddChar("SBC(14);DCV24(18,200,'");
 376   2            res[6] = '\0';
 377   2            uart2AddChar(res+4);
 378   2            uart2AddChar("%',16);");
 379   2            uart2SendEnd();
 380   2          }
 381   1      }
 382          char * getAllEnv()
 383          {
 384   1        getTempStr();
 385   1        sprintf(temp1,"%s;",res);
 386   1        getPressureStr();
 387   1        sprintf(temp1,"%s%s;",temp1,res);
 388   1        getWetStr();
 389   1        sprintf(temp1,"%s%s;",temp1,res);
 390   1        getLightStr();
 391   1        sprintf(temp1,"%s%s;",temp1,res);
 392   1        return temp1;
 393   1      }
 394          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2451    ----
   CONSTANT SIZE    =    143    ----
   XDATA SIZE       =     72    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      74
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
