C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ENV
OBJECT MODULE PLACED IN .\Objects\env.obj
COMPILER INVOKED BY: E:\C\keil\C51\BIN\C51.EXE User\env.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\User) DEBUG PRINT(.\Lis
                    -tings\env.lst) TABS(2) OBJECT(.\Objects\env.obj)

line level    source

   1          #include "env.h"
   2          #include "uart.h"
   3          #include "math.h"
   4          sbit wet = P2^2;
   5          #define light_address 0x46                //光照传感器
   6          #define BMP085_SlaveAddress   0xee        //气压传感器
   7          #define JUDGE  30                         //湿度传感器阈值
   8          #define uchar unsigned char
   9          #define uint unsigned int
  10          /*****
  11          光照传感器
  12          ******/
  13          float temp;
  14          /*****
  15          气压传感器
  16          ******/
  17          xdata short ac1,ac2,ac3,b1,b2,mb,mc,md;
  18          xdata unsigned short ac4,ac5,ac6;
  19          xdata long  temperature,pressure;
  20          /*****
  21          湿度传感器
  22          ******/
  23          xdata uchar wet_data = 0;
  24          xdata uchar   ge,shi,bai,qian,wan,shiwan;
  25          xdata uchar res[] = "111111\r\n"; //结果
  26          
  27          
  28          //------延迟函数------------
  29          void delay(uint t)    //@11.0592MHz
  30          {
  31   1        uint i,j,k;
  32   1        for(k=0;k<t;k++)
  33   1        for( i=0; i<10; i++)
  34   1        for( j=0; j<95; j++);
  35   1      }
  36          /*********************
  37                转换函数
  38          **********************/
  39          void conversion(long temp_data)  
  40          {
  41   1          shiwan=temp_data/100000+0x30 ;
  42   1          temp_data=temp_data%100000;   //取余运算 
  43   1          wan=temp_data/10000+0x30 ;
  44   1          temp_data=temp_data%10000;   //取余运算
  45   1        qian=temp_data/1000+0x30 ;
  46   1          temp_data=temp_data%1000;    //取余运算
  47   1          bai=temp_data/100+0x30   ;
  48   1          temp_data=temp_data%100;     //取余运算
  49   1          shi=temp_data/10+0x30    ;
  50   1          temp_data=temp_data%10;      //取余运算
  51   1          ge=temp_data+0x30;  
  52   1      }
  53          void light_write(uchar regis)
  54          {
C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 2   

  55   1        start();
  56   1        write_byte(light_address);
  57   1        write_byte(regis);
  58   1        stop();
  59   1      }
  60          void light_start(void)
  61          {
  62   1        light_write(0x01);
  63   1        light_write(0x10);
  64   1        delay(200);
  65   1      }
  66          
  67          float light_read(void)
  68          {   
  69   1        uchar i;
  70   1        uchar BUF[8];
  71   1        int dis_data;
  72   1        start();                          //起始信号
  73   1        write_byte(light_address+1);         //发送设备地址+读信号
  74   1        for (i=0; i<3; i++)                      //连续读取2个地址数据，存储中BUF
  75   1        {
  76   2          BUF[i] = read_byte();          //BUF[0]存储0x32地址中的数据
  77   2          if (i == 3)
  78   2          {
  79   3             send_respons(1);                //最后一个数据需要回NOACK
  80   3          }
  81   2          else
  82   2          {   
  83   3            send_respons(0);                //回应ACK
  84   3         }
  85   2        }
  86   1        stop();                          //停止信号
  87   1        delay(5);
  88   1        dis_data=BUF[0];
  89   1        dis_data=(dis_data<<8)+BUF[1];//合成数据，即光照数据
  90   1        temp = (float)dis_data/1.2;
  91   1        return temp;
  92   1      }
  93          uchar* getLightStr(void)
  94          {
  95   1        conversion(temp);         //计算数据和显示
  96   1        res[5] = ge;
  97   1        res[4] = shi;
  98   1        res[3] = bai;
  99   1        res[2] = qian;
 100   1        res[1] = wan;
 101   1        res[0] = shiwan;
 102   1        return res;
 103   1      }
 104          /*****************
 105            气压传感器
 106          ******************/
 107          //*********************************************************
 108          //读出BMP085内部数据,连续两个
 109          //*********************************************************
 110          short press_Multiple_read(uchar ST_Address)
 111          {
 112   1        uchar msb, lsb;
 113   1        short _data;
 114   1        start();                          //起始信号
 115   1        write_byte(BMP085_SlaveAddress);    //发送设备地址+写信号
 116   1        write_byte(ST_Address);             //发送存储单元地址
C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 3   

 117   1        start();                          //起始信号
 118   1        write_byte(BMP085_SlaveAddress+1);         //发送设备地址+读信号
 119   1      
 120   1        msb = read_byte();                 //BUF[0]存储
 121   1        send_respons(0);                       //回应ACK
 122   1        lsb = read_byte();     
 123   1        send_respons(1);                       //最后一个数据需要回NOACK
 124   1      
 125   1        stop();                           //停止信号
 126   1        delay(5);
 127   1        _data = msb << 8;
 128   1        _data |= lsb; 
 129   1        return _data;
 130   1      }
 131          long bmp085ReadTemp(void)
 132          {
 133   1      
 134   1          start();                  //起始信号
 135   1          write_byte(BMP085_SlaveAddress);   //发送设备地址+写信号
 136   1          write_byte(0xF4);           // write register address
 137   1          write_byte(0x2E);         // write register data for temp
 138   1          stop();                   //发送停止信号
 139   1          delay(10);  // max time is 4.5ms
 140   1        return (long) press_Multiple_read(0xF6);
 141   1      }
 142          long bmp085ReadPressure(void)
 143          {
 144   1        long pressure = 0;
 145   1        start();                   //起始信号
 146   1        write_byte(BMP085_SlaveAddress);   //发送设备地址+写信号
 147   1        write_byte(0xF4);           // write register address
 148   1        write_byte(0x34);           // write register data for pressure
 149   1        stop();                    //发送停止信号
 150   1        delay(10);                        // max time is 4.5ms
 151   1        pressure = press_Multiple_read(0xF6);
 152   1        pressure &= 0x0000FFFF;
 153   1        return pressure;  
 154   1      }
 155          void press_init()
 156          {
 157   1        ac1 = press_Multiple_read(0xAA);
 158   1        ac2 = press_Multiple_read(0xAC);
 159   1        ac3 = press_Multiple_read(0xAE);
 160   1        ac4 = press_Multiple_read(0xB0);
 161   1        ac5 = press_Multiple_read(0xB2);
 162   1        ac6 = press_Multiple_read(0xB4);
 163   1        b1 =  press_Multiple_read(0xB6);
 164   1        b2 =  press_Multiple_read(0xB8);
 165   1        mb =  press_Multiple_read(0xBA);
 166   1        mc =  press_Multiple_read(0xBC);
 167   1        md =  press_Multiple_read(0xBE);
 168   1      }
 169          long get_temperature()
 170          {
 171   1        long ut;
 172   1        long x1, x2, b5;
 173   1        ut = bmp085ReadTemp();     // 读取温度
 174   1        x1 = ((long)ut - ac6) * ac5 >> 15;
 175   1        x2 = ((long) mc << 11) / (x1 + md);
 176   1        b5 = x1 + x2;
 177   1        temperature = (b5 + 8) >> 4;
 178   1        return temperature;
C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 4   

 179   1      }
 180          uchar* getTempStr(void)
 181          {
 182   1        conversion(temperature);        
 183   1        res[5] = ge;
 184   1        res[4] = shi;
 185   1        res[3] = bai;
 186   1        res[2] = qian;
 187   1        res[1] = wan;
 188   1        res[0] = shiwan;
 189   1        return res;
 190   1      }
 191          long get_pressure()
 192          {
 193   1        long up;
 194   1        long x1, x2, b5, b6, x3, b3, p;
 195   1        unsigned long b4, b7;
 196   1        up = bmp085ReadPressure();  // 读取压强
 197   1        b6 = b5 - 4000;
 198   1        x1 = (b2 * (b6 * b6 >> 12)) >> 11;
 199   1        x2 = ac2 * b6 >> 11;
 200   1        x3 = x1 + x2;
 201   1        b3 = (((long)ac1 * 4 + x3) + 2)/4;
 202   1        x1 = ac3 * b6 >> 13;
 203   1        x2 = (b1 * (b6 * b6 >> 12)) >> 16;
 204   1        x3 = ((x1 + x2) + 2) >> 2;
 205   1        b4 = (ac4 * (unsigned long) (x3 + 32768)) >> 15;
 206   1        b7 = ((unsigned long) up - b3) * (50000 >> 0);
 207   1        if( b7 < 0x80000000)
 208   1          p = (b7 * 2) / b4 ;
 209   1        else  
 210   1          p = (b7 / b4) * 2;
 211   1        x1 = (p >> 8) * (p >> 8);
 212   1        x1 = (x1 * 3038) >> 16;
 213   1        x2 = (-7357 * p) >> 16;
 214   1        pressure = p + ((x1 + x2 + 3791) >> 4);
 215   1        return pressure;
 216   1      }
 217          uchar* getPressureStr(void)
 218          {
 219   1        conversion(pressure);        
 220   1        res[5] = ge;
 221   1        res[4] = shi;
 222   1        res[3] = bai;
 223   1        res[2] = qian;
 224   1        res[1] = wan;
 225   1        res[0] = shiwan;
 226   1        return res;
 227   1      }
 228          /*****************
 229            湿度传感器
 230          ******************/
 231          void Delay30us()
 232          {
 233   1        unsigned char i;
 234   1      
 235   1        i = 80;
 236   1        while (--i);
 237   1      }
 238          void Delay20ms()
 239          {
 240   1        unsigned char i, j, k;
C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 5   

 241   1      
 242   1        i = 1;
 243   1        j = 216;
 244   1        k = 35;
 245   1        do
 246   1        {
 247   2          do
 248   2          {
 249   3            while (--k);
 250   3          } while (--j);
 251   2        } while (--i);
 252   1      }
 253          uchar GetData (void)
 254          {
 255   1        uchar i,j;                                //for循环变量
 256   1        uchar t;                                //超时判断
 257   1        uchar dat8=0;                        //一次读取的8位数据，需要读5次
 258   1        wet = 0;                                //主机发起始信号
 259   1        Delay20ms();                        //主机拉低总线至少18ms
 260   1        wet = 1;                                //主机拉高总线20~40us
 261   1        Delay30us();
 262   1        t = 80;                                        //设置超时等待时间
 263   1        while(wet && t--);                //等待DHT11拉低总线
 264   1        if(t == 0)                                //超时
 265   1        {
 266   2          wet = 1;
 267   2          return 0;                        //通信错误退出，返回错误信号：-1
 268   2        }
 269   1        //等80us响应信号
 270   1        t = 250;                                //设置超时等待时间
 271   1        while(!wet && t--);        //等待DHT11拉高总线
 272   1        if(t == 0)                                //超时
 273   1        {
 274   2          wet = 1;
 275   2          return 0;                        //通信错误退出，返回错误信号：-2
 276   2        }
 277   1        //等80us响应信号
 278   1        t = 250;                                //设置超时等待时间
 279   1        while(wet && t--);                //等待DHT11拉低总线
 280   1        if(t == 0)                                //超时
 281   1        {
 282   2          wet = 1;
 283   2          return 0;                        //通信错误退出，返回错误信号：-3
 284   2        }
 285   1      
 286   1        for(j=0; j<5; j++)                //5次读取
 287   1        {
 288   2          for(i=0; i<8; i++)                        //1次8个位
 289   2          {
 290   3            //等待50us开始时隙
 291   3            t = 150;                                //设置超时等待时间
 292   3            while(!wet && t--);        //等待DHT11拉高总线
 293   3            if(t == 0)                                //超时
 294   3            {
 295   4              wet = 1;
 296   4              return 0;                        //通信错误退出，返回错误信号：-4
 297   4            }
 298   3            t = 0;                                        //记录时间清零
 299   3            while(wet && ++t);                //等待并记录高电平持续时间
 300   3            dat8 <<= 1;
 301   3            if(t > JUDGE)                        //高电平持续时间较长(70us)
 302   3              dat8 += 1;                        //传输值为1
C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 6   

 303   3          }
 304   2          if(j == 0)
 305   2            wet_data = dat8;
 306   2        }
 307   1        Delay30us();                //等待DHT11拉低50us
 308   1        Delay30us();
 309   1        wet = 1;                        //结束，拉高总线
 310   1        return wet_data;                        //返回成功信号
 311   1      }
 312          uchar* getWetStr(void)
 313          {
 314   1        conversion(wet_data);        
 315   1        res[5] = ge;
 316   1        res[4] = shi;
 317   1        res[3] = bai;
 318   1        res[2] = qian;
 319   1        res[1] = wan;
 320   1        res[0] = shiwan;
 321   1        return res;
 322   1      }
 323          /*****************
 324            显示温度
 325          ******************/
 326          void showTemperature()
 327          {
 328   1        get_temperature();
 329   1        getTempStr();
 330   1        uart2Clear();
 331   1      //  uart2AddChar("SBC(1);DCV24(255,50,'25℃',16);");
 332   1        uart2AddChar("SBC(1);DCV24(245,50,'");
 333   1        uart2AddCharLen(res+3,1);
 334   1        uart2AddCharLen(res+4,1);
 335   1        uart2AddChar(".");
 336   1        uart2AddCharLen(res+5,1);
 337   1        uart2AddChar("℃',16);");
 338   1        uart2SendEnd();
 339   1        
 340   1      }
 341          void showPress()
 342          {
 343   1        get_pressure();
 344   1        getPressureStr();
 345   1        uart2Clear();
 346   1        uart2AddChar("SBC(49);DCV16(170,164,'");
 347   1        res[4] = res[3];
 348   1        res[3] = '.';
 349   1        res[5] = '\0';
 350   1        uart2AddChar(res);
 351   1        uart2AddChar("KPa',16);");
 352   1        uart2SendEnd();
 353   1      }
 354          void showLight()
 355          {
 356   1        uchar i;
 357   1        light_start();
 358   1        light_read();
 359   1        getLightStr();
 360   1        uart2Clear();
 361   1        uart2AddChar("SBC(13);DCV16(103,200,'");
 362   1        while(res[i++] == '0');
 363   1        i--;
 364   1        res[6] = '\0';
C51 COMPILER V9.54   ENV                                                                   05/29/2021 11:41:49 PAGE 7   

 365   1        uart2AddChar(res+i);
 366   1        uart2AddChar("Lux ',16);");
 367   1        uart2SendEnd();
 368   1      }
 369          void showWet()
 370          {
 371   1          if(GetData())
 372   1          {
 373   2            getWetStr();
 374   2            uart2Clear();
 375   2            uart2AddChar("SBC(14);DCV24(18,200,'");
 376   2            res[6] = '\0';
 377   2            uart2AddChar(res+4);
 378   2            uart2AddChar("%',16);");
 379   2            uart2SendEnd();
 380   2          }
 381   1      }
 382          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2328    ----
   CONSTANT SIZE    =    133    ----
   XDATA SIZE       =     46    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      74
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
